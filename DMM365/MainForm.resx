<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="lblProject.Text" xml:space="preserve">
    <value>Steps:

1.  Start with creating configuretion Migration package with Entities records you want to migrate
     from source cmr instance. The package will contain all records found in source crm.

2.  Check the checkbox above to start new migration project.
     Choose or create a directory for a new project. Directory name becomes the poject name.

3.  Establish connection to Crm source instance

4.  Once prompted, select location of "zip" package created with Configuration Manager in the first step.

5   Project folders will be created in the  select directory and you will be redirect to Modify Data tab. 
     Configure Save views as filters form migration. 

6.  Use configuration Migration tool to import created package to target crm instance.</value>
  </data>
  <metadata name="folderBrowserDialogLoadProject.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="openFileDialogLoadSchema.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>659, 20</value>
  </metadata>
  <metadata name="openFileLoadProject.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>445, 16</value>
  </metadata>
  <metadata name="openFileAttachments.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>905, 20</value>
  </metadata>
  <data name="lblAbout1content.Text" xml:space="preserve">
    <value>Saved views as Data Migration filters

Use Saved vies created in crm to modify Configuration Migration tool data files. You can manage data migration granularity based on field valies, dates of modification/creation etc.
The tool does not create views, they must be pre-creadted. You also should connect to crm with apprpriated user to be able to read saved views.
DMM365 queries crm using fetch xml from saved views then edits data files leaving only records those match query results. You can select one or more queries.
Once selected query you can transform its fetch with  trransformation settings. See more in "Saved Views filters" tab.
          
         </value>
  </data>
  <data name="lblAbout2content.Text" xml:space="preserve">
    <value>Originally this module was created as Portals 365 migration helper. The current addition has option to do it for any entity (active/inactive) which can have attachements.

First section of the tab helps copy attachments (notes) from one crm to anoter. Copy process can base on data file containing entities which attchments need to be copied.
There is a section dedicated to copy Web Files attachments from portla to portal. Portals can reside in same or differnt instance or tenant. Appropriated credentials are need for 
source and target connections. The whole process can be rolled back if you have marked settings to save newly created Attachment IDs in separate file. 

Site Settings sync section will help to synchronise Site Settings entities from source Portal to target Portal.        
         </value>
  </data>
  <data name="lblAbout3content.Text" xml:space="preserve">
    <value>Creates full data file copy with new guids. References are properly updated and saved.

Duplication can be done based on original data file or data file createdby Saved Views migration filters.    
The douplicator is very usefull in Portals 365 deployment. See Project Wiki for full process description.         </value>
  </data>
  <data name="label1.Text" xml:space="preserve">
    <value>Execute As List Of Linked Queries

If there is any linked entites in the fetch then app will transform them to separate query.
Dependency to main entity will remain as condition. A list of queries, including original,
will be executed and result will be distincted by ID.</value>
  </data>
  <data name="label4.Text" xml:space="preserve">
    <value>Selecting the option will take you "Portals 365 sync" tab.

All methods works for for any crm entitiy (able to have attachments) except "Sync Portal Site Settings" 
and "Copy Web File attchments". These two are didicated support Portals 365 deployment.</value>
  </data>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>120</value>
  </metadata>
</root>